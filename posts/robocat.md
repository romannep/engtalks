## Развлечение для инженера


*тут три картинки в одной*
![эволюция](robocat/robo-homo.png)

Когда я принес домой набор для сборки программируемого робота-квадропода,
сразу появилось желание сделать с ним что-нибудь интересное. 
Про Arduino, конечно, я и раньше знал, но на изучение схемотехники
не было ни ресурсов ни желания. Набор полностью решал этот вопрос - 
вся аппаратная часть была уже сделана. 
Я потратил час на сборку и приступил к экспериментам.

---

## Квадропод

Малыш получился весьма забавный. Демо программа привела в восторг не
только детей, но и меня. В комплекте было приложение для 
визуального программирования квадропода a la Scratch, 
с помощью которого можно было заставить его ходить, поворачиваться,
делать наклоны и много чего еще.

--тут гифка--

https://ondrej-kvasnovsky.medium.com/how-to-convert-video-to-gif-on-macos-821343b6670d

![квадропод](robocat/robo-quadro.png)

Как-то случайно получилось так, что я расправил лапы квадроподу 
и повернул его пузом к себе. Глаза дальномера довершили картину - 
получился человекоподобный робот. Пути назад не было.

## Робот

Решение для ступней нашлось дня через три. Хотелось сделать
неразрушающую и одновременно разбираемую модификацию. Элементы
системы выравнивания плитки я решил использовать сразу. Не сразу
только придумал как. Лапы конусообразные - любые попытки расклинить
их не увенчались успехом - было ненадежно - выдавливались. В итоге,
воспользовался тем, что они полые - в стенках СВП просверлил
отверстия и продел сквозь них и сквозь лапу обычную скрепку, закрутив
по концам.

--фото--

Квадропод эволюционировал до прямоходящего робота - стал 
уверенно стоять на ногах.


![эволюция](robocat/robo-homo.png)
С Arduino до этого никогда не сталкивался, поэтому решил пойти
по "простому" пути: посмотреть как оно сделано в приложении с блоками
и сделать по аналогии.

Это оказалось возможным - приложение было на Electron с открытыми
js файлами. Покопавшись, я примерно понял как управлять сервоприводами, 
чего для начала было достаточно. Внутрь приложения можно было и не 
лазить - в нем самом сделана кнопка, которая показывает
сгенерированный код. Позже таки пришлось заглянуть в мануал, чтоб
разобраться как отправлять данные в порт, чтоб получить аналог
console.log.

Первая мысль была про обучение программированию детей. Сейчас оно,
зачастую, представлено задачами на управление роботом на экране.
Если двигаться будет не нарисованный, а реальный робот - это
будет гораздо интересней. Тем более, что с реальным роботом
и спектр задач может быть гораздо шире.

Реальность внесла свои корректировки. С двумя сервоприводами на
ногу сделать точное и устойчивое перемещение вперед - непростая задача.
Сделать поворот на точный угол - уже, прям скажем, сложная.
Тут уже ногами из СВП не обойдешься. Это уже выходило 
за рамки развлечения.

Наблюдая за весельем детей под танцы из Just Dance,
я подумал - а может научить робота танцевать?

## Makeba

-- картинка из JustDance c названием --

И так, танец. Движения в ритм музыки. Приступим.

Для начала, надо разобраться со временем. Чтоб попадать в такт,
нам нужно научиться двигаться с нужной скоростью.
Для управления сервоприводами используется библиотека `VarSpeedServo`,
которая позволяет указать и угол и скорость. Однако, скорость тут - 
величина абстрактная. Нужно привязать ее к конкретной величине.

Экспериментальным путем была выявлена константа,
которую я назвал `anglePerSecondPerSpeedUnit` -
угол, на который изменится положение сервопривода, на единицу 
абстрактной скорости за 1 секунду.

Примерно прикинув, как я буду описывать движения, пришел к выводу,
что мне нужна функция, которая подвинет сервопривод на определенный
угол за заданное количество миллисекунд.

Для удобства, функция принимает в качестве параметра целевое
положение - то, где сервопривод должен оказаться. Сама
определяет разницу от текущего положения и перемещает 
сервопривод туда, куда надо за нужное время. 
Когда программируешь танец, хочется не думать, где рука, плечо, 
голень были - хочется сказать в какое положение они должный
прийти и за какое время.

````
void _moveByTime(int index, int a, int timeMs) {
  int diff = a * _getDirection(index);
  int newAngle = _init[index] + diff;
  int length = abs(_state[index] - newAngle);
  int absSpeed = length * 1000 / timeMs;
  int speed = absSpeed / _anglePerSecondPerSpeedUnit;
  VarSpeedServo servo = _getServo(index);
  servo.slowmove(newAngle, speed > 255 ? 255 : speed);
  _state[index] = newAngle;
}
````

Почти сразу я встрял на дебаг. На маленьких углах функция работала
идеально, а на больших - сервопривод дрыгался непредсказуемо.
Сперва я подумал, что зависимость реальной скорости к параметру - нелинейная. Однако пара тестов показала, что это не так.

Решение нашел через час. И знаете что я вам скажу...
"Какая гадость это ваша динамическая типизация"

https://pikabu.ru/story/kakaya_gadost_yeta_vasha_dinamicheskaya_tipizatsiya_11491316

Я, конечно, давно использую Typescript, но это не то же самое.
Работающий код от неработающего отделяло только `(long)`:

````
  int absSpeed = (long)length * 1000 / timeMs;
````

Остается только добавить историю про [Линуса Торвальдса, джина и три желания](https://pikabu.ru/story/otvet_na_post_yeto_1010_12384900). 

---

Следующим сюрпризом стала длительность такта выбранной музыкальной 
композиции. Я, конечно, подбирал ее экспериментально - замеряя
секундомером длительность большого количества тактов.
Результат меня удивил. 

Обычно, для указания темпа используют понятную абсолютную величину - долю
минуты - bpm - beat per minute. В нотах часто задают длительность четверти - т.е. 
1/4 такта. По замерам на большом интервале, длительность такта в 
этой композиции в версии Just Dance составила 1020 миллисекунд. 
Если пересчитать по тактам, получится 58,82 такта в минуту, 
если по четвертям - 235,29 bpm.
Такие значения никак не вписываются в рамки здравого смысла. Рядовые
синтезаторы даже не смогут выдать темп с такой частотой. 

Но. Давайте разделим 1020 на четверти. 255 миллисекунд длится четверть
такта в этой композиции в интерпретации Just Dance. Разработчики
Ubisoft сделали забавную пасхалку :).

----

Разбор танца на движения и программирование робота было рядовой
технической задачей. Хочется лишь отметить, что научить человека (себя 
или кого-нибудь другого) нужным движениям сильно проще, чем механизм.
Если человек чувствует ритм - большую часть работы он делает сам - 
достаточно лишь показать. Механизму нужны предельно точные инструкции
относительно того, когда начинать движение и за какое время его надо
выполнить.

Может кто помнит, как герой из Энциклопедии Фортрана пытался
показать, что алгоритм обычной ходьбы очень простой :).


## Робокот


ps. Отзывчивость поддержки производителя

